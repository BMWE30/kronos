// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kronos/pb/kronos.proto

package kronospb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "context"
import grpc "google.golang.org/grpc"

import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ServerStatus int32

const (
	// Server is not the oracle and has not synced with the oracle
	// It cannot respond to KronosTime requests
	ServerStatus_NOT_INITIALIZED ServerStatus = 0
	// Server is the oracle or has synced with any oracle
	// It can respond to KronosTime requests if it is the current oracle.
	// KronosTime of initialized servers are valid
	ServerStatus_INITIALIZED ServerStatus = 1
)

var ServerStatus_name = map[int32]string{
	0: "NOT_INITIALIZED",
	1: "INITIALIZED",
}
var ServerStatus_value = map[string]int32{
	"NOT_INITIALIZED": 0,
	"INITIALIZED":     1,
}

func (x ServerStatus) String() string {
	return proto.EnumName(ServerStatus_name, int32(x))
}
func (ServerStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorKronos, []int{0} }

type NodeAddr struct {
	// Host of the node address
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Port of the node address
	Port string `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *NodeAddr) Reset()                    { *m = NodeAddr{} }
func (m *NodeAddr) String() string            { return proto.CompactTextString(m) }
func (*NodeAddr) ProtoMessage()               {}
func (*NodeAddr) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{0} }

type OracleState struct {
	// Current id. This is used for CAS operations
	// id is a sequence
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Upper bound to time generated by Kronos
	TimeCap int64 `protobuf:"varint,2,opt,name=time_cap,json=timeCap,proto3" json:"time_cap,omitempty"`
	// Address of current oracle
	Oracle *NodeAddr `protobuf:"bytes,3,opt,name=oracle" json:"oracle,omitempty"`
}

func (m *OracleState) Reset()                    { *m = OracleState{} }
func (m *OracleState) String() string            { return proto.CompactTextString(m) }
func (*OracleState) ProtoMessage()               {}
func (*OracleState) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{1} }

type OracleProposal struct {
	// Proposal to update the oracle
	ProposedState *OracleState `protobuf:"bytes,1,opt,name=proposed_state,json=proposedState" json:"proposed_state,omitempty"`
}

func (m *OracleProposal) Reset()                    { *m = OracleProposal{} }
func (m *OracleProposal) String() string            { return proto.CompactTextString(m) }
func (*OracleProposal) ProtoMessage()               {}
func (*OracleProposal) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{2} }

// Node stores the data of a single node that is persisted in cluster info on
// each node.
type Node struct {
	// raft_addr is the address of raft transport of the node.
	RaftAddr *NodeAddr `protobuf:"bytes,1,opt,name=raft_addr,json=raftAddr" json:"raft_addr,omitempty"`
	// is_removed is true for nodes which have been removed from the kronos raft
	// cluster. Removed node IDs cannot be added back to the cluster.
	IsRemoved bool `protobuf:"varint,2,opt,name=is_removed,json=isRemoved,proto3" json:"is_removed,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{3} }

// Cluster stores the information about cluster that is persisted on each node.
type Cluster struct {
	// all_nodes is a map of NodeId -> Node metadata. This is the same id which is
	// used by raft.
	// This map contains both active nodes and nodes removed from the cluster.
	AllNodes map[string]*Node `protobuf:"bytes,1,rep,name=all_nodes,json=allNodes" json:"all_nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{4} }

type OracleTimeRequest struct {
}

func (m *OracleTimeRequest) Reset()                    { *m = OracleTimeRequest{} }
func (m *OracleTimeRequest) String() string            { return proto.CompactTextString(m) }
func (*OracleTimeRequest) ProtoMessage()               {}
func (*OracleTimeRequest) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{5} }

type OracleTimeResponse struct {
	// time is the KronosTime of the oracle.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// rtt is the round-trip time for the rpc. this is actually filled on the
	// client side.
	Rtt int64 `protobuf:"varint,2,opt,name=rtt,proto3" json:"rtt,omitempty"`
}

func (m *OracleTimeResponse) Reset()                    { *m = OracleTimeResponse{} }
func (m *OracleTimeResponse) String() string            { return proto.CompactTextString(m) }
func (*OracleTimeResponse) ProtoMessage()               {}
func (*OracleTimeResponse) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{6} }

type KronosTimeRequest struct {
}

func (m *KronosTimeRequest) Reset()                    { *m = KronosTimeRequest{} }
func (m *KronosTimeRequest) String() string            { return proto.CompactTextString(m) }
func (*KronosTimeRequest) ProtoMessage()               {}
func (*KronosTimeRequest) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{7} }

type KronosTimeResponse struct {
	// time is the KronosTime
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// time_cap is an upper bound to KronosTime. This is periodically updated by
	// the oracle. If the oracle goes down and no new oracle is elected, or if
	// quorum is lost in the cluster, time_cap is used to as a safety measure so
	// that clusters stop serving time. Any time greater than time_cap may not be
	// reliable and not close to actual KronosTime.
	TimeCap int64 `protobuf:"varint,2,opt,name=time_cap,json=timeCap,proto3" json:"time_cap,omitempty"`
	// rtt is the round-trip time for the rpc. this is actually filled on the
	// client side.
	Rtt int64 `protobuf:"varint,3,opt,name=rtt,proto3" json:"rtt,omitempty"`
}

func (m *KronosTimeResponse) Reset()                    { *m = KronosTimeResponse{} }
func (m *KronosTimeResponse) String() string            { return proto.CompactTextString(m) }
func (*KronosTimeResponse) ProtoMessage()               {}
func (*KronosTimeResponse) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{8} }

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{9} }

type StatusResponse struct {
	ServerStatus ServerStatus `protobuf:"varint,1,opt,name=server_status,json=serverStatus,proto3,enum=kronospb.ServerStatus" json:"server_status,omitempty"`
	OracleState  *OracleState `protobuf:"bytes,2,opt,name=oracle_state,json=oracleState" json:"oracle_state,omitempty"`
	Delta        int64        `protobuf:"varint,3,opt,name=delta,proto3" json:"delta,omitempty"`
}

func (m *StatusResponse) Reset()                    { *m = StatusResponse{} }
func (m *StatusResponse) String() string            { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()               {}
func (*StatusResponse) Descriptor() ([]byte, []int) { return fileDescriptorKronos, []int{10} }

func init() {
	proto.RegisterType((*NodeAddr)(nil), "kronospb.NodeAddr")
	proto.RegisterType((*OracleState)(nil), "kronospb.OracleState")
	proto.RegisterType((*OracleProposal)(nil), "kronospb.OracleProposal")
	proto.RegisterType((*Node)(nil), "kronospb.Node")
	proto.RegisterType((*Cluster)(nil), "kronospb.Cluster")
	proto.RegisterType((*OracleTimeRequest)(nil), "kronospb.OracleTimeRequest")
	proto.RegisterType((*OracleTimeResponse)(nil), "kronospb.OracleTimeResponse")
	proto.RegisterType((*KronosTimeRequest)(nil), "kronospb.KronosTimeRequest")
	proto.RegisterType((*KronosTimeResponse)(nil), "kronospb.KronosTimeResponse")
	proto.RegisterType((*StatusRequest)(nil), "kronospb.StatusRequest")
	proto.RegisterType((*StatusResponse)(nil), "kronospb.StatusResponse")
	proto.RegisterEnum("kronospb.ServerStatus", ServerStatus_name, ServerStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TimeService service

type TimeServiceClient interface {
	// OracleTime returns the server's KronosTime if the server believes it is
	// the oracle, otherwise it returns an error.
	// A distributed state machine is used to store the identity of the oracle
	// and it is used by the server to know if it should respond to OracleTime
	// requests.
	// This RPC is used internally by kronos nodes to sync time with the elected
	// oracle.
	// This returns an error if
	// 1. The server is not the current oracle.
	// 2. The server is not initialized.
	// 3. The server's KronosTime is stale (KronosTime > Time Cap). This can
	//    mean that the cluster has lost a quorum of the nodes.
	OracleTime(ctx context.Context, in *OracleTimeRequest, opts ...grpc.CallOption) (*OracleTimeResponse, error)
	// KronosTime returns the server's KronosTime. An application can call this
	// RPC on the local kronos server to get access to KronosTime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosTime (KronosTime > Time Cap).
	KronosTime(ctx context.Context, in *KronosTimeRequest, opts ...grpc.CallOption) (*KronosTimeResponse, error)
	// Status returns the status of the server.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
}

type timeServiceClient struct {
	cc *grpc.ClientConn
}

func NewTimeServiceClient(cc *grpc.ClientConn) TimeServiceClient {
	return &timeServiceClient{cc}
}

func (c *timeServiceClient) OracleTime(ctx context.Context, in *OracleTimeRequest, opts ...grpc.CallOption) (*OracleTimeResponse, error) {
	out := new(OracleTimeResponse)
	err := grpc.Invoke(ctx, "/kronospb.TimeService/OracleTime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeServiceClient) KronosTime(ctx context.Context, in *KronosTimeRequest, opts ...grpc.CallOption) (*KronosTimeResponse, error) {
	out := new(KronosTimeResponse)
	err := grpc.Invoke(ctx, "/kronospb.TimeService/KronosTime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timeServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := grpc.Invoke(ctx, "/kronospb.TimeService/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TimeService service

type TimeServiceServer interface {
	// OracleTime returns the server's KronosTime if the server believes it is
	// the oracle, otherwise it returns an error.
	// A distributed state machine is used to store the identity of the oracle
	// and it is used by the server to know if it should respond to OracleTime
	// requests.
	// This RPC is used internally by kronos nodes to sync time with the elected
	// oracle.
	// This returns an error if
	// 1. The server is not the current oracle.
	// 2. The server is not initialized.
	// 3. The server's KronosTime is stale (KronosTime > Time Cap). This can
	//    mean that the cluster has lost a quorum of the nodes.
	OracleTime(context.Context, *OracleTimeRequest) (*OracleTimeResponse, error)
	// KronosTime returns the server's KronosTime. An application can call this
	// RPC on the local kronos server to get access to KronosTime.
	// This does not validate whether the server is the oracle.
	// This returns an error if the server is not initialized or has
	// a stale KronosTime (KronosTime > Time Cap).
	KronosTime(context.Context, *KronosTimeRequest) (*KronosTimeResponse, error)
	// Status returns the status of the server.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
}

func RegisterTimeServiceServer(s *grpc.Server, srv TimeServiceServer) {
	s.RegisterService(&_TimeService_serviceDesc, srv)
}

func _TimeService_OracleTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OracleTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).OracleTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/OracleTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).OracleTime(ctx, req.(*OracleTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeService_KronosTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KronosTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).KronosTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/KronosTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).KronosTime(ctx, req.(*KronosTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimeService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kronospb.TimeService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TimeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kronospb.TimeService",
	HandlerType: (*TimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OracleTime",
			Handler:    _TimeService_OracleTime_Handler,
		},
		{
			MethodName: "KronosTime",
			Handler:    _TimeService_KronosTime_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _TimeService_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kronos/pb/kronos.proto",
}

func (m *NodeAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeAddr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKronos(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	return i, nil
}

func (m *OracleState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Id))
	}
	if m.TimeCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.TimeCap))
	}
	if m.Oracle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Oracle.Size()))
		n1, err := m.Oracle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *OracleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProposedState != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.ProposedState.Size()))
		n2, err := m.ProposedState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.RaftAddr.Size()))
		n3, err := m.RaftAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.IsRemoved {
		dAtA[i] = 0x10
		i++
		if m.IsRemoved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllNodes) > 0 {
		keysForAllNodes := make([]string, 0, len(m.AllNodes))
		for k := range m.AllNodes {
			keysForAllNodes = append(keysForAllNodes, string(k))
		}
		sortkeys.Strings(keysForAllNodes)
		for _, k := range keysForAllNodes {
			dAtA[i] = 0xa
			i++
			v := m.AllNodes[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovKronos(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovKronos(uint64(len(k))) + msgSize
			i = encodeVarintKronos(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKronos(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintKronos(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *OracleTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *OracleTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Time))
	}
	if m.Rtt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Rtt))
	}
	return i, nil
}

func (m *KronosTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KronosTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KronosTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Time))
	}
	if m.TimeCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.TimeCap))
	}
	if m.Rtt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Rtt))
	}
	return i, nil
}

func (m *StatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.ServerStatus))
	}
	if m.OracleState != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.OracleState.Size()))
		n5, err := m.OracleState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Delta != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKronos(dAtA, i, uint64(m.Delta))
	}
	return i, nil
}

func encodeVarintKronos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeAddr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovKronos(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovKronos(uint64(l))
	}
	return n
}

func (m *OracleState) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovKronos(uint64(m.Id))
	}
	if m.TimeCap != 0 {
		n += 1 + sovKronos(uint64(m.TimeCap))
	}
	if m.Oracle != nil {
		l = m.Oracle.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	return n
}

func (m *OracleProposal) Size() (n int) {
	var l int
	_ = l
	if m.ProposedState != nil {
		l = m.ProposedState.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.RaftAddr != nil {
		l = m.RaftAddr.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	if m.IsRemoved {
		n += 2
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if len(m.AllNodes) > 0 {
		for k, v := range m.AllNodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovKronos(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovKronos(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovKronos(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OracleTimeRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *OracleTimeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovKronos(uint64(m.Time))
	}
	if m.Rtt != 0 {
		n += 1 + sovKronos(uint64(m.Rtt))
	}
	return n
}

func (m *KronosTimeRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *KronosTimeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovKronos(uint64(m.Time))
	}
	if m.TimeCap != 0 {
		n += 1 + sovKronos(uint64(m.TimeCap))
	}
	if m.Rtt != 0 {
		n += 1 + sovKronos(uint64(m.Rtt))
	}
	return n
}

func (m *StatusRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StatusResponse) Size() (n int) {
	var l int
	_ = l
	if m.ServerStatus != 0 {
		n += 1 + sovKronos(uint64(m.ServerStatus))
	}
	if m.OracleState != nil {
		l = m.OracleState.Size()
		n += 1 + l + sovKronos(uint64(l))
	}
	if m.Delta != 0 {
		n += 1 + sovKronos(uint64(m.Delta))
	}
	return n
}

func sovKronos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKronos(x uint64) (n int) {
	return sovKronos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCap", wireType)
			}
			m.TimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Oracle == nil {
				m.Oracle = &NodeAddr{}
			}
			if err := m.Oracle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposedState == nil {
				m.ProposedState = &OracleState{}
			}
			if err := m.ProposedState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftAddr == nil {
				m.RaftAddr = &NodeAddr{}
			}
			if err := m.RaftAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRemoved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRemoved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllNodes == nil {
				m.AllNodes = make(map[string]*Node)
			}
			var mapkey string
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKronos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKronos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKronos
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKronos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthKronos
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthKronos
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKronos(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKronos
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllNodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KronosTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KronosTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KronosTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCap", wireType)
			}
			m.TimeCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStatus", wireType)
			}
			m.ServerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerStatus |= (ServerStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKronos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleState == nil {
				m.OracleState = &OracleState{}
			}
			if err := m.OracleState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			m.Delta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delta |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKronos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKronos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKronos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKronos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKronos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKronos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKronos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKronos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKronos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKronos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kronos/pb/kronos.proto", fileDescriptorKronos) }

var fileDescriptorKronos = []byte{
	// 592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0xc6, 0xfd, 0x70, 0xc6, 0x8d, 0x5b, 0xb6, 0x50, 0x42, 0x01, 0x53, 0x59, 0x1c, 0xaa,
	0x1e, 0x52, 0xc9, 0x70, 0xa8, 0x4a, 0x39, 0x94, 0xd2, 0x43, 0x54, 0x94, 0x22, 0xb7, 0x70, 0xe8,
	0xc5, 0x72, 0xb3, 0x8b, 0xb0, 0xea, 0x64, 0xcd, 0xee, 0x26, 0x52, 0xff, 0x05, 0x07, 0xae, 0xfc,
	0x9f, 0x1e, 0x39, 0x72, 0x84, 0xf0, 0x47, 0xd0, 0xae, 0xd7, 0x78, 0x4b, 0xaa, 0xdc, 0xe6, 0x63,
	0xe7, 0xbd, 0xe7, 0x79, 0x23, 0xc3, 0xc6, 0x15, 0x67, 0x23, 0x26, 0x76, 0x8b, 0xcb, 0xdd, 0x32,
	0xea, 0x16, 0x9c, 0x49, 0x86, 0xdd, 0x32, 0x2b, 0x2e, 0xc3, 0x08, 0xdc, 0x3e, 0x23, 0xf4, 0x90,
	0x10, 0x8e, 0x31, 0x2c, 0x7c, 0x66, 0x42, 0x76, 0xd0, 0x16, 0xda, 0x6e, 0xc5, 0x3a, 0x56, 0xb5,
	0x82, 0x71, 0xd9, 0x69, 0x96, 0x35, 0x15, 0x87, 0x04, 0xbc, 0x53, 0x9e, 0x0e, 0x72, 0x7a, 0x26,
	0x53, 0x49, 0xb1, 0x0f, 0xcd, 0x8c, 0xe8, 0xa1, 0x85, 0xb8, 0x99, 0x11, 0xfc, 0x08, 0x5c, 0x99,
	0x0d, 0x69, 0x32, 0x48, 0x0b, 0x3d, 0xe6, 0xc4, 0xcb, 0x2a, 0x3f, 0x4a, 0x0b, 0xbc, 0x03, 0x4b,
	0x4c, 0x4f, 0x76, 0x9c, 0x2d, 0xb4, 0xed, 0x45, 0xb8, 0x5b, 0x09, 0xe9, 0x56, 0x2a, 0x62, 0xf3,
	0x22, 0xec, 0x83, 0x5f, 0xb2, 0xbc, 0xe7, 0xac, 0x60, 0x22, 0xcd, 0xf1, 0x01, 0xf8, 0x85, 0x8e,
	0x29, 0x49, 0x84, 0xa2, 0xd6, 0xa4, 0x5e, 0xf4, 0xa0, 0x46, 0xb1, 0x74, 0xc5, 0xed, 0xea, 0xb1,
	0x4e, 0xc3, 0x8f, 0xb0, 0xa0, 0x38, 0xf0, 0x2e, 0xb4, 0x78, 0xfa, 0x49, 0x26, 0x29, 0x21, 0xdc,
	0x00, 0xdc, 0x25, 0xc3, 0x55, 0x8f, 0xf4, 0x5a, 0x9e, 0x02, 0x64, 0x22, 0xe1, 0x74, 0xc8, 0x26,
	0x94, 0xe8, 0x2f, 0x72, 0xe3, 0x56, 0x26, 0xe2, 0xb2, 0x10, 0x7e, 0x43, 0xb0, 0x7c, 0x94, 0x8f,
	0x85, 0xa4, 0x1c, 0x1f, 0x40, 0x2b, 0xcd, 0xf3, 0x64, 0xc4, 0x08, 0x15, 0x1d, 0xb4, 0xe5, 0x6c,
	0x7b, 0xd1, 0xb3, 0x1a, 0xdb, 0xbc, 0xea, 0x1e, 0xe6, 0xb9, 0xa2, 0x11, 0xc7, 0x23, 0xc9, 0xaf,
	0x63, 0x37, 0x35, 0xe9, 0xe6, 0x09, 0xb4, 0x6f, 0xb5, 0xf0, 0x1a, 0x38, 0x57, 0xf4, 0xda, 0xf8,
	0xa1, 0x42, 0xfc, 0x1c, 0x16, 0x27, 0x69, 0x3e, 0xa6, 0x5a, 0x86, 0x17, 0xf9, 0xb7, 0x85, 0xc7,
	0x65, 0x73, 0xbf, 0xb9, 0x87, 0xc2, 0x75, 0xb8, 0x57, 0x2e, 0xe3, 0x3c, 0x1b, 0xd2, 0x98, 0x7e,
	0x19, 0x53, 0x21, 0xc3, 0x7d, 0xc0, 0x76, 0x51, 0x14, 0x6c, 0x24, 0xa8, 0xf2, 0x58, 0x19, 0xa4,
	0x79, 0x9c, 0x58, 0xc7, 0x8a, 0x9a, 0x4b, 0x69, 0xfc, 0x53, 0xa1, 0x02, 0x3c, 0xd1, 0x64, 0x36,
	0xe0, 0x07, 0xc0, 0x76, 0x71, 0x0e, 0xe0, 0x9c, 0xab, 0x30, 0x5c, 0x4e, 0xcd, 0xb5, 0x0a, 0x6d,
	0x65, 0xda, 0x58, 0x54, 0x3c, 0xdf, 0x11, 0xf8, 0x55, 0xc5, 0x90, 0xbc, 0x82, 0xb6, 0xa0, 0x7c,
	0x42, 0xb9, 0xbe, 0x85, 0xb1, 0xd0, 0x6c, 0x7e, 0xb4, 0x51, 0xaf, 0xe4, 0x4c, 0xb7, 0xcd, 0xd8,
	0x8a, 0xb0, 0x32, 0xbc, 0x07, 0x2b, 0xe5, 0x99, 0x99, 0x43, 0x6a, 0xce, 0x3b, 0x24, 0x8f, 0x59,
	0xd7, 0x7e, 0x1f, 0x16, 0x09, 0xcd, 0x65, 0x6a, 0xe4, 0x96, 0xc9, 0xce, 0x4b, 0x58, 0xb1, 0xd9,
	0xf0, 0x3a, 0xac, 0xf6, 0x4f, 0xcf, 0x93, 0x5e, 0xbf, 0x77, 0xde, 0x3b, 0x7c, 0xd7, 0xbb, 0x38,
	0x7e, 0xbb, 0xd6, 0xc0, 0xab, 0xe0, 0xd9, 0x05, 0x14, 0x4d, 0x11, 0x78, 0x6a, 0x71, 0x6a, 0x34,
	0x1b, 0x50, 0xdc, 0x03, 0xa8, 0xed, 0xc1, 0x8f, 0xff, 0x57, 0x63, 0x2d, 0x7e, 0xf3, 0xc9, 0xdd,
	0xcd, 0x72, 0x37, 0x61, 0x43, 0x41, 0xd5, 0xc6, 0xd8, 0x50, 0x33, 0x1e, 0xda, 0x50, 0xb3, 0x5e,
	0x86, 0x0d, 0xfc, 0x1a, 0x96, 0xcc, 0x57, 0x3d, 0xb4, 0x76, 0x6b, 0xdb, 0xb3, 0xd9, 0x99, 0x6d,
	0x54, 0xe3, 0x6f, 0xc2, 0x9b, 0xdf, 0x41, 0xe3, 0x66, 0x1a, 0xa0, 0x1f, 0xd3, 0x00, 0xfd, 0x9c,
	0x06, 0xe8, 0xd7, 0x34, 0x40, 0x5f, 0xff, 0x04, 0x8d, 0x8b, 0x7f, 0x7f, 0xa1, 0xcb, 0x25, 0xfd,
	0x5b, 0x7a, 0xf1, 0x37, 0x00, 0x00, 0xff, 0xff, 0xaa, 0x66, 0x3f, 0xec, 0xb0, 0x04, 0x00, 0x00,
}
